#if UNITY_EDITOR && ANNULUS_CODEGEN && UNITY_LOCALIZATION && ENCOSY_MVVM_ADAPTERS_GENERATOR

using System;
using EncosyTower.Modules.CodeGen;
using UnityCodeGen;

namespace EncosyTower.Modules.Editor.Mvvm.ViewBinding.Adapters.Localization
{
    [Generator]
    internal class L10nKeyToStringAdaptersGenerator : ICodeGenerator
    {
        private readonly static TypeData[] s_types = new TypeData[] {
            new($"L10nKey", "L10nKey"),
            new($"L10nKey<string>", "L10nKeyString"),
            new($"L10nKey.Serializable", "L10nKeySerializable"),
            new($"L10nKey.Serializable<string>", "L10nKeyStringSerializable"),
        };

        private readonly static ReturnExpData[] s_returnExps = new ReturnExpData[] {
            new("key.Entry.Key", "ToEntryKey", "Entry Key"),
            new("key.Table.TableCollectionName", "ToTableCollectionName", "Table Collection Name"),
            new("key.ToString()", "ToTableAndKeyFormat", "Table & Key Format: \\\"table,key\\\""),
        };

        public void Execute(GeneratorContext context)
        {
            var nameofGenerator = nameof(L10nKeyToStringAdaptersGenerator);

            if (CodeGenAPI.TryGetOutputFolderPath(nameofGenerator, out var outputPath) == false)
            {
                context.OverrideFolderPath("Assets");
                return;
            }

            var p = Printer.DefaultLarge;
            p.PrintLine("#if UNITY_LOCALIZATION").PrintEndLine();
            p.PrintAutoGeneratedBlock(nameofGenerator);
            p.PrintEndLine();
            p.PrintLine(@"// ReSharper disable InconsistentNaming

#pragma warning disable

using System;
using EncosyTower.Modules.Localization;
using EncosyTower.Modules.Unions;
");

            p.PrintLine("namespace EncosyTower.Modules.Mvvm.ViewBinding.Adapters.Localization");
            p.OpenScope();
            {
                var types = s_types.AsSpan();
                var returnExps = s_returnExps.AsSpan();

                foreach (var (type, typeName) in types)
                {
                    var order = 0;

                    foreach (var (returnExp, expName, expLabel) in returnExps)
                    {
                        p.PrintLine("[Serializable]");
                        p.PrintLine($"[Label(\"{type} â‡’ {expLabel}\", \"Default\")]");
                        p.PrintLine($"[Adapter(sourceType: typeof({type}), destType: typeof(string), order: {order})]");
                        p.PrintLine($"public class {typeName}{expName}Adapter : IAdapter");
                        p.OpenScope();
                        {
                            p.PrintLine("public Union Convert(in Union union)");
                            p.OpenScope();
                            {
                                p.PrintLine($"var converter = Union<{type}>.GetConverter();");
                                p.PrintEndLine();

                                p.PrintLine($"if (converter.TryGetValue(union, out {type} key) && key.IsValid)");
                                p.OpenScope();
                                {
                                    p.PrintLine($"return {returnExp};");
                                }
                                p.CloseScope();
                                p.PrintEndLine();

                                p.PrintLine("return union;");
                            }
                            p.CloseScope();
                        }
                        p.CloseScope();
                        p.PrintEndLine();

                        order += 1;
                    }
                }
            }
            p.CloseScope();
            p.PrintEndLine();
            p.PrintLine("#endif").PrintEndLine();

            context.OverrideFolderPath(outputPath);
            context.AddCode($"L10nKeyToStringAdapters.gen.cs", p.Result);
        }

        private readonly record struct TypeData(string Type, string Name);

        private readonly record struct ReturnExpData(string Exp, string Name, string Label);
    }
}

#endif
